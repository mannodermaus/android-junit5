import extensions.library
import extensions.libs
import org.apache.tools.ant.filters.ReplaceTokens
import org.gradle.api.DefaultTask
import org.gradle.api.Project
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.TaskAction
import java.io.File
import java.time.ZonedDateTime
import javax.inject.Inject

fun findInstrumentationVersion(
    pluginVersion: String = Artifacts.Plugin.currentVersion,
    currentInstrumentationVersion: String = Artifacts.Instrumentation.Core.currentVersion,
    stableInstrumentationVersion: String = Artifacts.Instrumentation.Core.latestStableVersion
): String {
    return when {
        pluginVersion.endsWith("-SNAPSHOT") -> currentInstrumentationVersion
        currentInstrumentationVersion.endsWith("-SNAPSHOT") -> stableInstrumentationVersion
        else -> currentInstrumentationVersion
    }
}

fun Copy.configureCreateVersionClassTask(
    instrumentationVersion: String = findInstrumentationVersion(),
    fromPath: String = "src/main/templates/Libraries.kt",
    intoPath: String = "build/generated/sources/plugin/de/mannodermaus",
) {
    from(fromPath)
    into(intoPath)
    filter(
        mapOf(
            "tokens" to mapOf(
                "INSTRUMENTATION_GROUP" to Artifacts.Instrumentation.groupId,
                "INSTRUMENTATION_COMPOSE" to Artifacts.Instrumentation.Compose.artifactId,
                "INSTRUMENTATION_CORE" to Artifacts.Instrumentation.Core.artifactId,
                "INSTRUMENTATION_EXTENSIONS" to Artifacts.Instrumentation.Extensions.artifactId,
                "INSTRUMENTATION_RUNNER" to Artifacts.Instrumentation.Runner.artifactId,

                // Find an appropriate version of the instrumentation library,
                // depending on the version of how the plugin is configured
                "INSTRUMENTATION_VERSION" to instrumentationVersion,

                // JUnit 5.12+ requires the platform launcher on the runtime classpath;
                // to prevent issues with version mismatching, the plugin applies this for users
                "JUNIT_PLATFORM_LAUNCHER" to project.libs.library("junit-platform-launcher").get().toString(),

                // Communicate all supported JUnit versions so the plugin can use them
                "SUPPORTED_JUNIT_VERSIONS" to SupportedJUnit.values().joinToString { junit ->
                    buildString {
                        append(junit.name)
                        append("(majorVersion=")
                        append(junit.majorVersion)
                        junit.artifactIdSuffix?.let {
                            append(", artifactIdSuffix=\"")
                            append(it)
                            append('\"')
                        }
                        append(')')
                    }
                }
            )
        ), ReplaceTokens::class.java
    )
    outputs.upToDateWhen { false }
}

/**
 * Helper Task class for generating an up-to-date version of the project's README.md.
 * Using a template file, the plugin's version constants & other dependency versions
 * are automatically injected into the README.
 */
abstract class GenerateReadme @Inject constructor(
    private val project: Project
) : DefaultTask() {
    companion object {
        private val PLACEHOLDER_REGEX = Regex("\\\$\\{(.+)}")
        private val EXTERNAL_DEP_REGEX = Regex("libs\\.(.+)")
        private val CONSTANT_REGEX = Regex("constants\\.(.+)")

        private const val PLUGIN_VERSION = "pluginVersion"
        private const val INSTRUMENTATION_VERSION = "instrumentationVersion"

        private const val CONSTANTS_FILE =
            "android-junit5/src/main/kotlin/de/mannodermaus/gradle/plugins/junit5/internal/config/Constants.kt"
        private val CONSTANTS_FILE_REGEX1 = Regex("""val (.*)\s*=\s*.+"(.*)".+""")
        private val CONSTANTS_FILE_REGEX2 = Regex("""val (.*)\s*=\s*AndroidPluginVersion\((\d+)\s*,\s*(\d+)\)""")
        private val CONSTANT_MAPPINGS = mapOf(
            "minimumRequiredGradleVersion" to "MIN_REQUIRED_GRADLE_VERSION",
            "minimumRequiredAgpVersion" to "MIN_REQUIRED_AGP_VERSION",
            "currentYear" to "CURRENT_YEAR",
        )

        private val GENERATED_HEADER_COMMENT = """
      <!--
        This file was automatically generated by Gradle. Do not modify.
        To update the content of this README, please apply modifications
        to `README.md.template` instead, and run the `generateReadme` task from Gradle.
      -->
      
    """.trimIndent()
    }

    @get:InputFile
    abstract val inputTemplateFile: RegularFileProperty

    @get:OutputFile
    abstract val outputFile: RegularFileProperty

    @TaskAction
    fun doWork() {
        val templateText = inputTemplateFile.asFile.get().readText()
        val constants = parseConstantsFile()
        val replacedText = replacePlaceholdersInTemplate(templateText, constants)

        outputFile.asFile.get().writeText(replacedText)
    }

    /* Private */

    private fun replacePlaceholdersInTemplate(templateText: String, constants: Map<String, String>): String {
        // Apply placeholders in the template with data from Versions.kt & Environment.kt:
        // ${pluginVersion}             Artifacts.Plugin.currentVersion
        // ${instrumentationVersion}    Artifacts.Instrumentation.Core.currentVersion
        // ${libs.<xxx>}                (A constant value taken from the version catalog)
        val allPlaceholders = mutableMapOf<String, String>()

        PLACEHOLDER_REGEX.findAll(templateText).forEach { match ->
            val placeholder = match.groups.last()?.value
                ?: throw InvalidPlaceholder(match)

            // Local versions (plugin, instrumentation)
            val replacement = when (placeholder) {
                PLUGIN_VERSION -> Artifacts.Plugin.anyStableVersion
                INSTRUMENTATION_VERSION -> Artifacts.Instrumentation.Core.anyStableVersion
                else -> {
                    val match2 = CONSTANT_REGEX.find(placeholder)
                    if (match2 != null) {
                        val key = match2.groups.last()?.value
                        val constantKey = CONSTANT_MAPPINGS[key] ?: throw InvalidPlaceholder(match2)
                        constants[constantKey] ?: throw InvalidPlaceholder(match2)

                    } else {
                        val match3 = EXTERNAL_DEP_REGEX.find(placeholder)
                            ?: throw InvalidPlaceholder(match)
                        val externalDependency = match3.groups.last()
                            ?.value
                            ?.replace('.', '-')
                            ?: throw InvalidPlaceholder(match3)

                        project.libs.library(externalDependency).get().toString()
                    }
                }
            }

            // Save placeholder
            allPlaceholders["\${$placeholder}"] = replacement
        }

        var replacedText = GENERATED_HEADER_COMMENT + templateText
        allPlaceholders.forEach { (key, value) ->
            replacedText = replacedText.replace(key, value)
        }
        return replacedText
    }

    private fun parseConstantsFile(): Map<String, String> {
        val constants = mutableMapOf<String, String>()
        val text = File(CONSTANTS_FILE).readText()

        // Add hardcoded constants
        constants["CURRENT_YEAR"] = ZonedDateTime.now().year.toString()

        CONSTANTS_FILE_REGEX1.findAll(text).forEach { match ->
            constants[match[1]] = match[2]
        }

        // Special case for AGP version
        CONSTANTS_FILE_REGEX2.findAll(text).forEach { match ->
            constants[match[1]] = match.groupValues
                .drop(2)
                .joinToString(separator = ".", transform = String::trim)
        }

        return constants
    }

    private operator fun MatchResult.get(index: Int): String {
        return this.groups[index]!!.value.trim()
    }
}

private class InvalidPlaceholder(matchResult: MatchResult) :
    Exception("Invalid match result: '${matchResult.groupValues}'")

private val Deployed.anyStableVersion: String
    get() = if (currentVersion.endsWith("-SNAPSHOT")) {
        latestStableVersion
    } else {
        currentVersion
    }
