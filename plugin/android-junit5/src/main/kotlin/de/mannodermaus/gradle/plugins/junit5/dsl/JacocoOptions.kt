package de.mannodermaus.gradle.plugins.junit5.dsl

import org.gradle.api.Action
import org.gradle.api.tasks.Input
import java.io.File

/**
 * Options for controlling Jacoco reporting
 */
public abstract class JacocoOptions {

    operator fun invoke(config: JacocoOptions.() -> Unit) {
        this.config()
    }

    /**
     * Whether to enable Jacoco task integration
     */
    @get:Input
    var taskGenerationEnabled = true

    fun taskGenerationEnabled(state: Boolean) {
        this.taskGenerationEnabled = state
    }

    private val _onlyGenerateTasksForVariants = mutableSetOf<String>()

    @get:Input
    val onlyGenerateTasksForVariants
        get() = _onlyGenerateTasksForVariants.toSet()

    /**
     * Filter the generated Jacoco tasks,
     * so that only the given build variants are provided with a companion task.
     * Make sure to add the full product flavor name if necessary
     * (i.e. "paidDebug" if you use a "paid" product flavor and the "debug" build type)
     */
    fun onlyGenerateTasksForVariants(vararg variants: String) {
        _onlyGenerateTasksForVariants.addAll(variants)
    }

    /**
     * Options for controlling the HTML Report generated by Jacoco
     */
    val html = Report()

    /**
     * Options for controlling the HTML Report generated by Jacoco
     */
    fun html(action: Action<Report>) {
        action.execute(html)
    }

    /**
     * Options for controlling the CSV Report generated by Jacoco
     */
    val csv = Report()

    /**
     * Options for controlling the CSV Report generated by Jacoco
     */
    fun csv(action: Action<Report>) {
        action.execute(csv)
    }

    /**
     * Options for controlling the XML Report generated by Jacoco
     */
    val xml = Report()

    /**
     * Options for controlling the XML Report generated by Jacoco
     */
    fun xml(action: Action<Report>) {
        action.execute(xml)
    }

    /**
     * List of class name patterns that should be excluded from being processed by Jacoco.
     * By default, this will exclude R.class & BuildConfig.class
     */
    var excludedClasses = mutableListOf("**/R.class", "**/R$*.class", "**/BuildConfig.*")

    fun excludedClasses(vararg classes: String) = excludedClasses.addAll(classes)

    class Report {

        operator fun invoke(config: Report.() -> Unit) {
            this.config()
        }

        /**
         * Whether or not this report should be generated
         */
        var enabled: Boolean = true

        fun enabled(state: Boolean) {
            this.enabled = state
        }

        /**
         * Name of the file to be generated; note that
         * due to the variant-aware nature of the plugin,
         * each variant will be assigned a distinct folder if necessary
         */
        var destination: File? = null

        fun destination(file: File?) {
            this.destination = file
        }
    }
}
